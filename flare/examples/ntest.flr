package Main = 
    # use Math.factorial
    # use Option.Option
    # use Option.unwrap
    #use Opt.Option
    #use Opt.unwrap
    #use Opt.unwrap_or
    #use Option

    extern println: str -> unit

    #extern concat: str -> str -> str
    extern format: ?T -> str
    extern tuple_to_seq: ?T -> Seq[?U]
    extern Seq: Seq[?T]
    #extern exit: num -> unit

    #struct S =
    #    d: str,
    #    f: str -> num -> str

    let id x : ?T -> ?T =
    # let id x = 
        x

    let looper limit f items : num -> Seq[?T] -> (?T -> unit) -> num =
        let looper_helper = fn c =>
            if c == limit then
                limit
            else
                let _ = f(items.c) in looper_helper(c+1)
         in
            looper_helper(0)
    
    # struct S =
    #     f: num
         
    let main =
        # let o = S {f = 3} in
        let test = 2 in
         let a = {"I", id("am"), "different"}  in
            let s = tuple_to_seq(a) in
            looper 2 s println 
             
        # let b = Option.Some {{3, 4, 5}.3} in
           # (unwrap a) * (unwrap b)

        # let i = S {d = "asdf", f = fn x y => concat x (display_num y)} in
        #    let en = Option.Some {"asdf"} in
        #         let f = factorial (unwrap en) in
        #                i.f i.d (f)
