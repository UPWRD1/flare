%start Module
%expect-unused Unmatched "UNMATCHED"
%%
Unmatched -> Result<(), ()>:
  "UNMATCHED" {Err(())} 
  ;

FType -> Result<SymbolType, ()>:
      "ty_int" {Ok(SymbolType::Int)}
    | "ty_flt" {Ok(SymbolType::Flt)}
    | "ty_str" {Ok(SymbolType::Str)}
    | "ty_bool" {Ok(SymbolType::Bool)}
    | "unit" {Ok(SymbolType::Unit)}
    | "?" SimpleSymbolExpr {Ok(SymbolType::Generic(crate::root::passes::midend::environment::GenericValue::Ref(format!("?_{}", $2?.get_symbol_name().unwrap()).to_string())))}
    | SimpleSymbolExpr {Ok(SymbolType::Custom($1?.get_symbol_name().unwrap().to_string(), vec![]))}
    ;

Module -> Result<Cst, ()>:
    ClauseList {Ok(Cst::Module {body: $1?, name: "TBD".to_string()})}
    ;

ClauseList -> Result<Vec<Cst>, ()>:
      Clause { Ok(vec![$1?]) }
    | ClauseList Clause { flatten($1, $2) }
    ;

Clause -> Result<Cst, ()>:
      LetClause {$1}
    | StructDef {$1}
    | DefBlock {$1}
    ;

StructDef -> Result<Cst, ()>:
    "struct" FType "=" FuncParams {Ok(Cst::Struct { name: $2?.get_custom_name(), members: $4? })}
    ;

DefBlock -> Result<Cst, ()>:
    "def" FType DefBlockClauseList {Ok(Cst::DefBlock {name: $2?, funcs: $3?})}
    ;

DefBlockClauseList -> Result<Vec<Cst>, ()>:
      InClause { Ok(vec![$1?]) }
    | DefBlockClauseList InClause { flatten($1, $2) }
    ;


LetClause -> Result<Cst, ()>:
    "let" FuncDef {$2}
    ;

InClause -> Result<Cst, ()>:
    "in" FuncDef {$2}
    ;


FuncDef -> Result<Cst, ()>:
      SimpleSymbolExpr ":" "(" ")" "->" FType "=" Expr {Ok(Cst::FnDef{ name: $1?.get_symbol_name().unwrap(), args: vec![], rettype: $6?, effect: None, limits: None, body: $8?})}
    | SimpleSymbolExpr ":" "(" FuncParams ")" "->" FType "=" Expr {Ok(Cst::FnDef{ name: $1?.get_symbol_name().unwrap(), args: $4?, rettype: $7?, effect: None, limits: None, body: $9?})}
    ;

FuncParams -> Result<Vec<(String, SymbolType)>, ()>:
      FuncParamItem { Ok(vec![$1?]) }
    | FuncParams "," FuncParamItem { flatten($1, $3) }
    ;

FuncParamItem -> Result<(String, SymbolType), ()>:
      "self" {Ok(("self".to_string(), SymbolType::Selff))}
    | TypedFuncParamItem {$1}
    ;

TypedFuncParamItem -> Result<(String, SymbolType), ()>:
    SimpleSymbolExpr ":" FType {Ok( ($1?.get_symbol_name().unwrap(), $3?))};

Expr -> Result<Expr, ()>:
    AssignmentExpr {$1}
    ;

AssignmentExpr -> Result<Expr, ()>:
      SimpleSymbolExpr "=" BinOpExpr BinOpExpr {Ok(Expr::Assignment {name: Box::new($1?), value: Box::new($3?), and_in: Box::new($4?) } ) }
    | BinOpExpr {$1}
    ;

BinOpExpr -> Result<Expr, ()>:
      BinOpExpr "&" LogicalExpr {Ok(Expr::SeqComp { l: Box::new($1?), r: Box::new($3?) })}
    | LogicalExpr {$1}
    ;

LogicalExpr -> Result<Expr, ()>:
      LogicalExpr "is" ComparisonExpr {Ok(Expr::Logical { l: Box::new($1?), op: crate::root::resource::cst::LogicOp::Is, r: Box::new($3?) })}
    | LogicalExpr "and" ComparisonExpr {Ok(Expr::Logical { l: Box::new($1?), op: crate::root::resource::cst::LogicOp::And, r: Box::new($3?) })}
    | LogicalExpr "or" ComparisonExpr {Ok(Expr::Logical { l: Box::new($1?), op: crate::root::resource::cst::LogicOp::Or, r: Box::new($3?) })}
    | ComparisonExpr {$1}
    ;

ComparisonExpr -> Result<Expr, ()>:
      ComparisonExpr "==" AddExpr {Ok(Expr::Logical { l: Box::new($1?), op: crate::root::resource::cst::LogicOp::CEQ, r: Box::new($3?) })}
    | ComparisonExpr "<" AddExpr {Ok(Expr::Logical { l: Box::new($1?), op: crate::root::resource::cst::LogicOp::CLT, r: Box::new($3?) })}
    | ComparisonExpr "<=" AddExpr {Ok(Expr::Logical { l: Box::new($1?), op: crate::root::resource::cst::LogicOp::CLE, r: Box::new($3?) })}
    | ComparisonExpr ">" AddExpr {Ok(Expr::Logical { l: Box::new($1?), op: crate::root::resource::cst::LogicOp::CGT, r: Box::new($3?) })}
    | ComparisonExpr ">=" AddExpr {Ok(Expr::Logical { l: Box::new($1?), op: crate::root::resource::cst::LogicOp::CGE, r: Box::new($3?) })}
    | AddExpr {$1}
    ;

AddExpr -> Result<Expr, ()>:
      AddExpr '+' MulExpr {
            Ok(Expr::BinAdd{l: Box::new($1?), r: Box::new($3?)})
        }
    | MulExpr { $1 }
    ;

MulExpr -> Result<Expr, ()>:
      MulExpr '*' PathExpr {
            Ok(Expr::BinMul{l: Box::new($1?), r: Box::new($3?)})
        }
    | PathExpr { $1 }
    ;

PathExpr -> Result<Expr, ()>:
    PathExpr '.' AtomExpr {Ok(Expr::Path(Box::new($1?), Box::new($3?)))}
    | AtomExpr { $1 }
    ;

AtomExpr -> Result<Expr, ()>:
      CallExpr {$1}
    | LiteralExpr {$1}
    | GroupingExpr {$1}
    | SymbolExpr {$1}
    ;

CallExpr -> Result<Expr, ()>:
    AtomExpr '(' CallListOpt {Ok(Expr::Call {name: Box::new($1?), args: $3?})}
    ;

CallListOpt -> Result<Vec<Expr>, ()>:
      ')' {Ok(vec![])}
    | CallList ')' {$1}
    ;

CallList -> Result<Vec<Expr>, ()>:
      Expr { Ok(vec![$1?]) }
    | CallList ',' Expr { flatten($1, $3) }
    ;

GroupingExpr -> Result<Expr, ()>:
      '(' Expr ')' {$2}
    ;

LiteralExpr -> Result<Expr, ()>:
      'INT' { 
        let v = $1.map_err(|_| ())?;
        Ok(Expr::Int(parse_int($lexer.span_str(v.span()))?)) 
        }
    | 'FLOAT' {
        let v = $1.map_err(|_| ())?;
        Ok(Expr::Flt(parse_flt($lexer.span_str(v.span()))?.into())) 
    }
    | "true" { Ok(Expr::Bool(true)) }
    | "false" { Ok(Expr::Bool(false)) }
    | SimpleSymbolExpr "{" StructConstructorList "}" {Ok(Expr::StructInstance { name: Box::new($1?), fields: $3? })}
    ;

StructConstructorList -> Result<Vec<(String, Expr)>, ()>:
      StructConstructorItem { Ok(vec![$1?]) }
    | StructConstructorList "," StructConstructorItem { flatten($1, $3) }
    ;

StructConstructorItem -> Result<(String, Expr), ()> :
    SimpleSymbolExpr ":" Expr {Ok(($1?.get_symbol_name().unwrap(), $3?))}
    ;

SymbolExpr -> Result<Expr, ()>:
      SimpleSymbolExpr {$1}
    | "self" {Ok(Expr::Selff)}
    ;

SimpleSymbolExpr -> Result<Expr, ()>:
    "SYMBOL" {Ok(Expr::Symbol($lexer.span_str($1.map_err(|_| ())?.span()).to_string()))}
    ;
%%
// Any functions here are in scope for all the grammar actions above.

use crate::root::resource::cst::Expr;
use crate::root::resource::cst::Cst;
use crate::root::resource::cst::SymbolType;

fn parse_int(s: &str) -> Result<i32, ()> {
    match s.parse::<i32>() {
        Ok(val) => Ok(val),
        Err(_) => {
            eprintln!("{} cannot be represented as a i32", s);
            Err(())
        }
    }
}

fn parse_flt(s: &str) -> Result<f32, ()> {
    match s.parse::<f32>() {
        Ok(val) => Ok(val),
        Err(_) => {
            eprintln!("{} cannot be represented as an f32", s);
            Err(())
        }
    }
}

fn flatten<T>(lhs: Result<Vec<T>, ()>, rhs: Result<T, ()>)
           -> Result<Vec<T>, ()>
{
    let mut flt = lhs?;
    flt.push(rhs?);
    Ok(flt)
}

